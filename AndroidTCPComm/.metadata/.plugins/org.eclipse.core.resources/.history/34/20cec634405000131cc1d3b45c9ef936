package com.example.gamecontrollerdatatransfer;

import gc.common_resources.CommandType;

import java.io.ObjectOutputStream;
import java.net.Socket;

import android.app.ActionBar.LayoutParams;
import android.app.Activity;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorManager;
import android.opengl.GLSurfaceView;
import android.os.Bundle;
import android.util.Log;


public class PlayActivity extends Activity {
	
	private String ipAddress;
	Socket socket = null;
    private boolean connected = false;
    private GLSurfaceView mGLSurfaceView;
    private SensorManager mSensorManager;
    private final double THRESHHOLD = 0.01;
    //private MyRenderer mRenderer;
    
    private final float[] mRotationMatrix = new float[16];
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Get an instance of the SensorManager
        mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);

        // Create our Preview view and set it as the content of our
        // Activity
        
        //mRenderer = new MyRenderer();
        mGLSurfaceView = (GLSurfaceView) findViewById(R.id.surfaceviewclass);
        //mGLSurfaceView.setRenderer(mRenderer);        
        
        setContentView(R.layout.activity_play);
        addContentView(mGLSurfaceView, new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
        /* do this in onCreate */
        Bundle extras = getIntent().getExtras(); 
		if (extras != null) {
			ipAddress = extras.getString("ipAddress");
        //clientConnection();
		}
	}
    
    

	
	public void updateCoordinates(TouchCoordinates tc, CommandType newCommand){
		// We don't keep a set of tc and commandtype in this class anymore
		// So this function only packs the command with fields and 
		// passes the data to sendPacketToServer()
		CommandType updateCommand = newCommand;
		updateCommand.setX(tc.getX());
		updateCommand.setY(tc.getY());
		
		sendPacketToServer(updateCommand);
	}

	// Create the threads and pass the commands to them
	public void sendPacketToServer(CommandType updateCommand){
		if (!connected) {
             Thread cThread = new Thread(new ClientSocketThread(updateCommand));
             cThread.start();
		}
	}
	
	//Thread class to send commands to the Server
	public class ClientSocketThread implements Runnable {
		
		private CommandType commandToSend;
		
		public ClientSocketThread(CommandType currCommand){
			commandToSend = currCommand;
			
			Log.d("PlayActivity - ThreadConstructor", "commandToSend: "+commandToSend+" "+ commandToSend.getX() +" "+ commandToSend.getY());
		}
		 
		public void run() {
	        try {
				Socket socket = new Socket(ipAddress, 8888);
		        ObjectOutputStream objOutputStream = new ObjectOutputStream(socket.getOutputStream());
		        connected = true;
		      		        
				try {		                
					Log.d("PlayActivity", "Sending: "+commandToSend+" "+ commandToSend.getX() +" "+ commandToSend.getY());
					
					// Send the enum(commandToSend) and the fields(X and Y) separately
					// as the serializing and deserializing of enum through ObjectOutputStream
					// and ObjectInputStream will not save the fields in the enum
					objOutputStream.writeObject(commandToSend);
					objOutputStream.writeFloat(commandToSend.getX());
					objOutputStream.writeFloat(commandToSend.getY());
	            } catch (Exception e) {
	                Log.e("PlayActivity", "S: Error", e);
	            }
				//Close outputstream and socket
				objOutputStream.close();
		        socket.close();
		        connected = false;
		    } catch (Exception e) {
		        Log.e("PlayActivity", "C: Error", e);
		    }
		}
	}		
        
        public void onSensorChanged(SensorEvent event) {
        // we received a sensor event. it is a good practice to check
        // that we received the proper event
	        if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {
	            // convert the rotation-vector to a 4x4 matrix. the matrix
	            // is interpreted by Open GL as the inverse of the
	            // rotation-vector, which is what we want.
	            SensorManager.getRotationMatrixFromVector(
	                    mRotationMatrix , event.values);
	            float values[] = event.values;
	            CommandType touchCommand = CommandType.DEFAULT;
	            System.out.println("X= "+values[0]+" Y= "+values[1]+" Z= "+values[2]);
	            System.out.println(touchCommand);
	            if(Math.abs(values[0])>THRESHHOLD&&values[0]>0) {
	            	//move right
	            	touchCommand= CommandType.VIEW;
	            	//wrapData(touchCommand,values[0],values[1],values[2]);
	            	System.out.println("MOVE RIGHT ON X"+touchCommand);
	            }
	            System.out.println("X= "+values[0]+" Y= "+values[1]+" Z= "+values[2]);
	            if(Math.abs(values[0])>THRESHHOLD&&values[0]<0) {
	            	//move left
	            	touchCommand= CommandType.VIEW;
	            	//wrapData(touchCommand,values[0],values[1],values[2]);
	
	            	System.out.println("MOVE LEFT ON X"+touchCommand);
	            }
	            	
	        }
        }

        
}